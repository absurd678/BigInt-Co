ОБЩАЯ СТРУКТУРА ПРОГРАММЫ

Программа состоит из 3 основных частей:
    Класс BigInt - собственная реализация больших чисел
    Методы проверки простоты - 4 разных алгоритма
    Основная программа - тестирование и демонстрация

------------------------------------------------------------------------
1. КЛАСС BigInt - РАБОТА С БОЛЬШИМИ ЧИСЛАМИ
Основная идея: Число хранится как массив цифр в обратном порядке

                                2. МЕТОДЫ ПРОВЕРКИ ПРОСТОТЫ
Программа реализует 4 разных алгоритма проверки простоты чисел

1. Стандартный метод (isPrimeStandard)
// Проверяет число 1000000007
bool result = BigInt::isPrimeStandard(BigInt("1000000007"));

Как работает:
    Проверяет делимость на 2 (четность)
    Проверяет делимость на 5
    Проверяет сумму цифр на делимость на 3
    Делит на все нечетные числа до квадратного корня


2. Решето Эратосфена (isPrimeEratosthenes)
bool result = BigInt::isPrimeEratosthenes(BigInt("1000000007"));

Как работает:
    Создает "решето" - массив true/false
    Вычеркивает кратные числа
    Оставшиеся "true" - простые числа


3. Решето Аткина (isPrimeAtkin)
bool result = BigInt::isPrimeAtkin(BigInt("1000000007"));

Как работает:
    Более современный алгоритм
    Использует математические модульные условия
    Быстрее чем решето Эратосфена для больших чисел


4. Тест Люка-Лемера (lucasLehmerTest)
// Проверяет, простое ли число Мерсенна M13 = 2¹³ - 1
bool result = BigInt::lucasLehmerTest(13);

----------------------------------------------------------------------------------------------

                                    3. ОСНОВНАЯ ПРОГРАММА - ЧТО ОНА ДЕЛАЕТ

Этап 1: Демонстрация теста Люка-Лемера

// Проверяет известные простые числа Мерсенна
M2 = 2² - 1 = 3 (простое)
M3 = 2³ - 1 = 7 (простое) 
M5 = 2⁵ - 1 = 31 (простое)
M7 = 2⁷ - 1 = 127 (простое)
M13 = 2¹³ - 1 = 8191 (простое)

----------
Этап 2: Основное задание - вычисление 2¹³⁶²⁷⁹⁸⁴¹ - 1

// Использует GMP для вычисления гигантского числа
calculateMersenneWithGMP(136279841, "Гигантское число Мерсенна");

Что происходит:
    Вычисляет 2¹³⁶²⁷⁹⁸⁴¹ - 1 (число с ~41 миллионом цифр!)
    Показывает первые 50 цифр
    Проверяет на простоту с помощью GMP
    Измеряет время вычисления

------------
Этап 3: Сравнение методов проверки простоты

// Тестирует на известных простых числах
testPrimalityMethods(BigInt("101"), "Малое простое");
testPrimalityMethods(BigInt("1000000007"), "Большое простое");

Сравнивает:
    Скорость работы каждого метода
    Точность результатов
    Эффективность для разных размеров чисел

--------------
Этап 4: Генерация случайных простых чисел

// Генерирует простые числа разного размера
BigInt prime1 = BigInt::generateRandomPrime(10, gen);  // 10 цифр
BigInt prime2 = BigInt::generateRandomPrime(20, gen);  // 20 цифр

------------------
ИЗМЕРЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ

auto start = chrono::high_resolution_clock::now();
// Выполняем операцию
auto end = chrono::high_resolution_clock::now();
auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);
cout << "Время: " << duration.count() << " мс" << endl;

СКОРОСТЬ АЛГОРИТМОВ:
    Маленькие числа (< 6 цифр): Все методы мгновенные (0 мс)
    Средние числа (7-8 цифр): 2-11 мс
    Большие числа (9-10 цифр): 22-84 мс
    Решето Аткина немного быстрее для больших чисел

ГЕНЕРАЦИЯ ПРОСТЫХ ЧИСЕЛ:
    5 цифр: мгновенно (0 мс) → число 58699
    10 цифр: 140 мс → число 3077445911

------------------------
Программа не вычисляет 2¹³⁶²⁷⁹⁸⁴¹ - 1 напрямую, а показывает:

ПРИМЕЧАНИЕ: Вычисление 2^136279841 - 1 собственными методами
потребует значительного времени и памяти.

Почему? Это число имеет ~41 миллион цифр! Его вычисление:
    Заняло бы гигабайты памяти
    Заняло бы часы или дни вычислений
    Требует специализированных алгоритмов
