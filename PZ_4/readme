--------------- АРХИТЕКТУРА ПРОГРАММЫ --------------------
1. Класс BigInt - работа с большими числами
2. Класс PrimalityTests - вероятностные тесты простоты
3. Основная программа - тестирование и демонстрация


-------------------------------------------------- ПЗ 4 --------------------------------------------------

### Что такое детерминированный тест на простоту?
Детерминированный тест - это алгоритм, который ВСЕГДА дает правильный ответ:
- Если число простое → вернет TRUE
- Если число составное → вернет FALSE

В отличие от вероятностных тестов (Миллера-Рабина), которые могут ошибаться.

### Основные теоремы:

Малая теорема Ферма:
Если p - простое число, то для любого целого a:
a^p ≡ a (mod p)

Теорема Агравала-Каяла-Саксены:
Число n > 1 является простым тогда и только тогда, когда:
(X + a)^n ≡ X^n + a (mod X^r - 1, n)
для всех a от 1 до некоторого предела.

--------------------------------------- Алгоритм AKS (6 шагов) --------------------------------------------------
В РЕАЛЬНОМ AKS тесте проверяется полиномиальное тождество:
  (X + a)^n ≡ X^n + a (mod X^r - 1, n) для всех a от 1 до L
 
  Где:
  - X - переменная полинома
  - r - специальный параметр, найденный на шаге 2
  - L = √φ(r) * log n - верхняя граница для a
  - φ(r) - функция Эйлера
  
  СМЫСЛ ЭТОГО ТЕСТА:
  Для простых чисел биномиальные коэффициенты C(n,k) делятся на n при 0 < k < n,
  поэтому в разложении (X+a)^n все промежуточные члены исчезают по модулю n,
  остаются только X^n и a.
  
  Для составных чисел некоторые промежуточные члены не исчезают, что нарушает тождество.

В НАШЕЙ РЕАЛИЗАЦИИ мы УПРОЩАЕМ проверку:
  вместо работы с полиномами в кольце Z/nZ[X]/(X^r-1)
  мы проверяем числовое равенство для нескольких значений X.
  Это не является полным AKS, но дает хорошее приближение.

bool DeterministicPrimality::checkPolynomialAKS(const BigInt& n, const BigInt& r) {
    // В реальном AKS: L = √φ(r) * log n
    // Мы используем упрощение: L = √r * 2 * log n
    BigInt sqrt_r = sqrt(r);
    BigInt log_n = BigInt::log(n);
    BigInt max_a = sqrt_r * log_n * BigInt(2);

Шаг 1: Проверка на совершенную степень. Если число можно представить как a^b (где b > 1), то оно составное.
Пример: 8 = 2^3, 16 = 4^2, 27 = 3^3

bool isPerfectPower(const BigInt& n) {
    // Проверяем, является ли n = a^b для некоторых a,b > 1
    // Если да - число составное
}
--------------------
Шаг 2: Нахождение параметра r. Нам нужно найти специальное число r, которое будет использоваться
в полиномиальной проверке.

BigInt findSmallestR(const BigInt& n) {
    // Ищем наименьшее r такое, что:
    // 1. gcd(r, n) = 1 (r и n взаимно просты)
    // 2. ord_r(n) > log²n (порядок n по модулю r)
}
---------------------
Шаг 3: Проверка малых делителей. Проверяем все числа от 2 до r. Если находим делитель - число составное.

for (BigInt a(2); a <= r && a < n; a = a + BigInt(1)) {
    BigInt gcd_val = BigInt::gcd(a, n);
    if (gcd_val > BigInt(1) && gcd_val < n) {
        return false; // Найден делитель
    }
}
--------------------
Шаг 4: Проверка n ≤ r. Если n меньше или равно r, то мы уже проверили все возможные делители.

if (n <= r) {
    return true; // Число простое
}
--------------------
Шаг 5: Полиномиальная проверка. Это САМЫЙ ВАЖНЫЙ шаг. Мы проверяем полиномиальное тождество.
В реальном AKS это требует работы с полиномами, но в нашей реализации мы используем числовую аппроксимацию для простоты.

bool checkPolynomialAKS(const BigInt& n, const BigInt& r) {
    // Проверяем для всех a от 1 до √φ(r) * log n:
    // (X + a)^n ≡ X^n + a (mod X^r - 1, n)
}


--------------------------------------- ТЕСТ МИЛЛЕРА --------------------------------------------------
Для чисел меньше 2^64 существуют известные наборы базисов, которые
гарантируют правильность теста. Это доказано математически.

Шаг 1: Подготовка. Раскладываем n-1 на нечетную часть и степень двойки.

void factorOutTwos(BigInt n_minus_one, BigInt& d, int& s) {
    // Представляем n-1 = d * 2^s
    // где d - нечетное число
}
--------------------
Шаг 2: Проверка базисов. Для разных диапазонов n существуют известные наборы базисов,
которые делают тест Миллера детерминированным.

vector<BigInt> bases;
if (n < BigInt("2047")) {
    bases = {BigInt(2)};
} else if (n < BigInt("1373653")) {
    bases = {BigInt(2), BigInt(3)};
}
// ... и так далее для разных диапазонов
--------------------
Шаг 3: Основная проверка

for (const BigInt& a : bases) {
    BigInt x = BigInt::modPow(a, d, n);
    if (x == BigInt(1) || x == n - BigInt(1)) {
        continue; // Свидетель простоты
    }
    
    // Проверяем последовательные возведения в квадрат
    for (int i = 0; i < s - 1; ++i) {
        x = (x * x) % n;
        if (x == n - BigInt(1)) {
            break; // Свидетель простоты
        }
    }
    
    // Если не нашли свидетель - число составное
    if (x != n - BigInt(1)) {
        return false;
    }
}




--------------------------------------------------- ПЗ 3 ---------------------------------------------

---------------- КЛАСС PrimalityTests - ВЕРОЯТНОСТНЫЕ ТЕСТЫ

Основная идея вероятностных тестов:
- Они не доказывают простоту на 100%, но дают высокую вероятность.
- Если тест говорит "простое" - оно вероятно простое.
- Если говорит "составное" - оно точно составное.

---- Метод 1: ТЕСТ МИЛЛЕРА-РАБИНА
Алгоритм:
- Проверка малых простых: 2, 3, 5, 7, 11...
- Разложение: n-1 = d × 2^s
- Случайные свидетели: Выбираем случайные числа a
- Проверка условий:
    Если a^d ≡ 1 (mod n) - вероятно простое
    Если a^(d×2^r) ≡ -1 (mod n) - вероятно простое
- Повторение: 10-25 раз для надежности

Пример для n = 101:
n-1 = 100 = 25 × 2² (d=25, s=2)
Проверяем a=2:
  2²⁵ mod 101 = 10 ≠ 1
  2⁵⁰ mod 101 = 100 ≡ -1 mod 101 ✓
Результат: вероятно простое


---- Метод 2: ТЕСТ ЛЮКА НА СИЛЬНУЮ ПСЕВДОПРОСТОТУ

Алгоритм:
- Находим параметры: Числа P, Q, D
- Последовательность Люка: Вычисляем Uₙ, Vₙ
- Проверка условий:
        Uₙ ≡ 0 (mod n)
        Vₙ ≡ 2 (mod n)
- Повторение: С разными параметрами

Пример:
Для n = 1000000007:
1. Находим D = 5 (подходящий параметр)
2. Вычисляем последовательность Люка
3. Проверяем Uₙ ≡ 0 mod n
4. Если условие выполняется → вероятно простое


---- Метод 3: ТЕСТ BPSW (Baillie-PSW)
// Комбинация двух тестов
return millerRabinTest(n) && lucasStrongTest(n);

----------------------- 3. ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ

Генерация свидетелей: 
vector<BigInt> witnesses = getWitnesses(n, 10); // Создает 10 случайных чисел от 2 до n-2

Проверка свидетеля:
bool is_witness = isWitness(a, n); // Проверяет, является ли a свидетелем составности n

Сравнение тестов:
PrimalityTests::compareAllTests(n, 50); // Запускает все 3 теста по 50 раз и сравнивает результаты


---------------------- 4. ОСНОВНАЯ ПРОГРАММА - ЧТО И КАК ТЕСТИРУЕТ

---- Этап 1: Демонстрация на одном числе
BigInt test_prime("1000000007");

// Тест Миллера-Рабина 100 раз
millerRabinStatistics(test_prime, 100);

// Тест Люка 100 раз  
lucasStrongStatistics(test_prime, 100);

// Тест BPSW 100 раз
bpswStatistics(test_prime, 100);

// Сравнение всех тестов
compareAllTests(test_prime, 100);


---- Этап 2: Тестирование на разных числах

vector<BigInt> test_numbers = {
    BigInt("101"),           // 3 цифры
    BigInt("1009"),          // 4 цифры
    BigInt("1000003"),       // 7 цифр
    BigInt("1000000007"),    // 10 цифр
    BigInt("10000000019")    // 11 цифр
};

---- Этап 3: Проверка с GMP

// Сравниваем наши результаты с промышленной библиотекой
mpz_class gmp_num("1000000007");
int gmp_result = mpz_probab_prime_p(gmp_num.get_mpz_t(), 25);
bool our_result = bpswTest(BigInt("1000000007"), 10);

---- Этап 4: Комплексный анализ

PrimalityTests::runComprehensiveAnalysis();

Тестирует:
 -   Разные размеры чисел (10-14 цифр)
 -   Статистику успешности
 -   Время выполнения
 -   Сравнение методов
